#!/usr/bin/python

import animal
import audit
import configuration
import datetime
import db
import dbfs
import dbupdate
import i18n
import lookups
import html
import person
import urllib2
import users
import utils
from sitedefs import BASE_URL, URL_REPORTS

HEADER = 0
FOOTER = 1

DEFAULT_REPORT_HEADER = """
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>$$TITLE$$</title>

<style>
* {
font-family: Verdana,Arial,Helvetica,Sans-Serif;
}
</style>
</head>

<body bgcolor="white" text="black">
<center>
<h2>$$TITLE$$</h2>
</center>
<hr />
"""

DEFAULT_REPORT_FOOTER = """
<hr />
<p>
Report: <b>$$TITLE$$</b><br />
Generated by Animal Shelter Manager $$VERSION$$ at $$REGISTEREDTO$$
on $$DATE$$ by $$USER$$
</p>
</body>
</html>
"""

def get_all_report_titles(dbo):
    """
    Returns a list of titles for every report on the system, does not
    include builtin reports since they don't count for ASM3 (and should be
    replaced when viewing available reports)
    """
    return db.query(dbo, "SELECT Title FROM customreport WHERE %s > 3 ORDER BY Title" % db.char_length(dbo, "HTMLBody"))

def get_available_reports(dbo, include_with_criteria = True):
    """
    Returns a list of reports available for running. The return
    value is a tuple of category, ID and title.
    If include_with_criteria is false, only reports that don't
    have ASK or VAR tags are included.
    """
    reps = []
    rs = get_reports(dbo)
    for r in rs:
        htmlbody = r["HTMLBODY"]
        sql = r["SQLCOMMAND"]
        # Ignore ASM 2.x builtin reports
        if htmlbody.startswith("0"):
            continue
        # Ignore mail merges
        if htmlbody.upper().startswith("MAIL"):
            continue
        # Ignore subreports
        if sql.find("$PARENTKEY$") != -1:
            continue
        # If we're excluding reports with criteria, check now
        if not include_with_criteria:
            if sql.find("$ASK") != -1 or sql.find("$VAR") != -1:
                continue
        reps.append(r)
    return reps

def get_available_mailmerges(dbo):
    """
    Returns a list of mail merges available for running. Return
    value is a tuple of category, ID and title.
    """
    reps = []
    rs = get_reports(dbo)
    for r in rs:
        if not r["HTMLBODY"].startswith("MAIL"): continue
        reps.append(r)
    return reps

def get_reports(dbo):
    """
    Returns a list of all reports on the system, filtering out any of
    the old ASM2 built in reports
    """
    reps = db.query(dbo, "SELECT * FROM customreport ORDER BY Category, Title")
    reps = [x for x in reps if not x["HTMLBODY"].startswith("0")]
    roles = db.query(dbo, "SELECT cr.*, r.RoleName FROM customreportrole cr INNER JOIN role r ON cr.RoleID = r.ID")
    for r in reps:
        viewroleids = []
        viewrolenames = []
        for o in roles:
            if o["REPORTID"] == r["ID"] and o["CANVIEW"] == 1:
                viewroleids.append(str(o["ROLEID"]))
                viewrolenames.append(str(o["ROLENAME"]))
        r["VIEWROLEIDS"] = "|".join(viewroleids)
        r["VIEWROLES"] = "|".join(viewrolenames)
    return reps

def get_report_header(dbo, title, username):
    """
    Returns the stock report header
    """
    r = Report(dbo)
    r.title = title
    r.user = username
    return r._ReadHeader()

def get_report_footer(dbo, title, username):
    """
    Returns the stock report footer
    """
    r = Report(dbo)
    r.title = title
    r.user = username
    return r._ReadFooter()

def get_categories(dbo):
    cat = db.query(dbo, "SELECT DISTINCT Category FROM customreport ORDER BY Category")
    rv = []
    for c in cat:
        rv.append(c["CATEGORY"])
    return rv

def get_title(dbo, customreportid):
    """
    Returns the title of a custom report from its ID
    """
    return db.query_string(dbo, "SELECT Title FROM customreport WHERE ID = %s" % str(customreportid))

def get_id(dbo, title):
    """
    Returns the id of a custom report from its title. 0 if not found.
    """
    return db.query_int(dbo, "SELECT ID FROM customreport WHERE Title Like '%" + title + "%'")

def is_mailmerge(dbo, crid):
    """
    Returns true if the report with crid is a mailmerge
    """
    return db.query_string(dbo, "SELECT HTMLBody FROM customreport WHERE ID = %d" % int(crid)).startswith("MAIL")

def get_criteria_params(dbo, customreportid, post):
    """
    Creates a list of criteria parameters to pass to a report. The post
    parameter contains the posted form data from a get_criteria_controls
    form below.
    """
    crit = Report(dbo).GetParams(customreportid)
    p = []
    l = dbo.locale
    for name, rtype, question in crit:
        if not post.has_key(name):
            raise utils.ASMValidationError("Missing parameter: %s" % name)
        if rtype == "DATE":
            p.append( ( name , question, db.python2db(i18n.display2python(l, post[name])), post[name]) )  
        elif rtype == "STRING":
            p.append( ( name, question, post[name], post[name] ) )
        elif rtype == "NUMBER":
            p.append( ( name, question, post[name], post[name] ) )
        elif rtype == "ANIMAL" or rtype == "FSANIMAL" or rtype == "ALLANIMAL":
            p.append( ( name, i18n._("Animal", l), post[name], animal.get_animal_namecode(dbo, post[name])) )
        elif rtype == "PERSON":
            p.append( ( name, i18n._("Person", l), post[name], person.get_person_name(dbo, post[name])) )
        elif rtype == "LITTER":
            p.append( ( name, i18n._("Litter", l), post[name], post[name]) )
        elif rtype == "SPECIES":
            p.append( ( name, i18n._("Species", l), post[name], lookups.get_species_name(dbo, post.integer(name) )) )
        elif rtype == "LOCATION":
            p.append( ( name, i18n._("Location", l), post[name], lookups.get_internallocation_name(dbo, post.integer(name) )) )
        elif rtype == "TYPE":
            p.append( ( name, i18n._("Type", l), post[name], lookups.get_animaltype_name(dbo, post.integer(name) )) )
    return p

def get_criteria_controls(dbo, customreportid, mode = "NORMAL", locationfilter = ""):
    """
    Renders criteria controls for the selected report as
    an html form. Returns an empty string for no criteria.
    mode: NORMAL for the main app, MOBILE for the mobile version
    locationfilter: A comma separated list of location ids for filtering the internal location list
    """
    crit = Report(dbo).GetParams(customreportid)
    if len(crit) == 0: return ""
    if mode == "NORMAL":
        return html.report_criteria(dbo, crit, locationfilter)
    else:
        return html.report_criteria_mobile(dbo, crit, locationfilter)

def check_view_permission(session, customreportid):
    """
    Checks that the currently logged in user has permission to
    view the report with customreportid.
    If they can't, an ASMPermissionError is thrown.
    """
    l = session.locale
    dbo = session.dbo
    # Superusers can do anything
    if session.superuser == 1: return True
    reportroles = []
    for rr in db.query(dbo, "SELECT RoleID FROM customreportrole WHERE ReportID = %d AND CanView = 1" % customreportid):
        reportroles.append(rr["ROLEID"])
    # No view roles means anyone can view
    if len(reportroles) == 0:
        return True
    # Does the user have any of the view roles?
    userroles = []
    for ur in db.query(dbo, "SELECT RoleID FROM userrole INNER JOIN users ON userrole.UserID = users.ID WHERE users.UserName LIKE %s" % db.ds(session.user)):
        userroles.append(ur["ROLEID"])
    hasperm = False
    for ur in userroles:
        if ur in reportroles:
            hasperm = True
    if hasperm:
        return True
    raise utils.ASMPermissionError(i18n._("No view permission for this report", l))

def insert_report_from_form(dbo, username, post):
    """
    Creates a report record from posted form data
    """
    rtype = post["type"]
    if rtype != "REPORT" and rtype != "":
        htmlbody = rtype
    else:
        htmlbody = post["html"]
    reportid = db.get_id(dbo, "customreport")
    sql = db.make_insert_user_sql(dbo, "customreport", username, ( 
        ( "ID", db.di(reportid)),
        ( "Title", post.db_string("title")),
        ( "Category", post.db_string("category")),
        ( "SQLCommand", post.db_string("sql")),
        ( "HTMLBody", db.ds(htmlbody) ),
        ( "DailyEmail", post.db_string("dailyemail")),
        ( "DailyEmailHour", post.db_integer("dailyemailhour")),
        ( "Description", post.db_string("description")),
        ( "OmitHeaderFooter", post.db_boolean("omitheaderfooter")),
        ( "OmitCriteria", post.db_boolean("omitcriteria"))
        ), False)
    db.execute(dbo, sql)
    audit.create(dbo, username, "customreport", str(reportid))
    db.execute(dbo, "DELETE FROM customreportrole WHERE ReportID = %d" % reportid)
    for rid in post.integer_list("viewroles"):
        db.execute(dbo, "INSERT INTO customreportrole (ReportID, RoleID, CanView) VALUES (%d, %d, 1)" % (reportid, rid))
    return reportid

def update_report_from_form(dbo, username, post):
    """
    Updates a report record from posted form data
    """
    reportid = post.integer("reportid")
    sql = db.make_update_user_sql(dbo, "customreport", username, "ID=%d" % reportid, ( 
        ( "Title", post.db_string("title")),
        ( "Category", post.db_string("category")),
        ( "SQLCommand", post.db_string("sql")),
        ( "HTMLBody", post.db_string("html")),
        ( "DailyEmail", post.db_string("dailyemail")),
        ( "DailyEmailHour", post.db_integer("dailyemailhour")),
        ( "Description", post.db_string("description")),
        ( "OmitHeaderFooter", post.db_boolean("omitheaderfooter")),
        ( "OmitCriteria", post.db_boolean("omitcriteria"))
        ), False)
    preaudit = db.query(dbo, "SELECT * FROM customreport WHERE ID = %d" % reportid)
    db.execute(dbo, sql)
    postaudit = db.query(dbo, "SELECT * FROM customreport WHERE ID = %d" % reportid)
    audit.edit(dbo, username, "customreport", audit.map_diff(preaudit, postaudit, [ "TITLE", ]))
    db.execute(dbo, "DELETE FROM customreportrole WHERE ReportID = %d" % reportid)
    for rid in post.integer_list("viewroles"):
        db.execute(dbo, "INSERT INTO customreportrole (ReportID, RoleID, CanView) VALUES (%d, %d, 1)" % (reportid, rid))

def delete_report(dbo, username, rid):
    """
    Deletes a report record
    """
    audit.delete(dbo, username, "customreport", str(db.query(dbo, "SELECT * FROM customreport WHERE ID = %d" % rid)))
    db.execute(dbo, "DELETE FROM customreportrole WHERE ReportID = %d" % rid)
    db.execute(dbo, "DELETE FROM customreport WHERE ID = %d" % rid)

def check_sql(dbo, username, sql):
    """
    Verifies that report sql works correctly. Returns the SELECT query,
    sanitised and in a ready-to-run state.
    If there is a problem with the query, an ASMValidationError is raised
    """
    queries = sql.split(";")
    lastquery = queries[-1]
    # Clean up and substitute some tags
    lastquery = lastquery.replace("$USER$", username)
    i = lastquery.find("$")
    while (i != -1):
        end = lastquery.find("$", i+1)
        sub = ""
        if lastquery[i:i+4] == "$VAR":
            # VAR tags don't need a substitution
            sub = ""
        elif len(lastquery) > (i + 9) and lastquery[i:i+9] == "$ASK DATE":
            # Use an old date
            sub = "2001-01-01"
        elif len(lastquery) > (i + 13) and lastquery[i:i+13] == "$CURRENT_DATE":
            # Use an old date
            sub = "2001-01-01"
        else:
            sub = "0"
        lastquery = lastquery[0:i] + sub + lastquery[end+1:]
        i = lastquery.find("$", i+1)
    # Make sure the last query is a SELECT or (SELECT
    if not lastquery.strip().lower().startswith("select") and \
       not lastquery.strip().lower().startswith("(select"):
        raise utils.ASMValidationError("There must be at least one SELECT query and it must be last to run")
    # Test the query
    try:
        db.query_tuple(dbo, lastquery)
    except Exception,e:
        raise utils.ASMValidationError(str(e))
    return lastquery

def generate_html(dbo, username, sql):
    """
    Runs the query given and returns some auto-generated HTML to
    output the data in a table.
    """
    sql = check_sql(dbo, username, sql)
    rs, cols = db.query_tuple_columns(dbo, sql)
    h = "$$HEADER\n<table border=\"1\">\n<tr>\n"
    b = "$$BODY\n<tr>\n"
    f = "$$FOOTER\n</table>\nFOOTER$$\n"
    for c in cols:
        h += "<th>%s</th>\n" % c
        b += "<td>$%s</td>\n" % c.upper()
    h += "</tr>\nHEADER$$\n\n"
    b += "</tr>\nBODY$$\n\n"
    return h + b + f

def get_smcom_reports(dbo):
    """
    Returns the full collection of sheltermanager.com reports
    as a list of dictionaries. Reports not suitable for this database
    type/version are automatically filtered out.
    [ { TITLE, CATEGORY, DATABASE, DESCRIPTION, LOCALE, SQL, HTML, SUBREPORTS } ]
    """
    l = dbo.locale
    loaded = get_all_report_titles(dbo)
    def version_ok(rdb):
        if rdb.find("/") == -1: return True
        ver = int(rdb[0:rdb.find("/")])
        return dbupdate.LATEST_VERSION >= ver
    def database_ok(rdb):
        if rdb.find("Any") != -1: return True
        if rdb.find("MySQL") != -1 and dbo.dbtype == "MYSQL": return True
        if rdb.find("PostgreSQL") != -1 and dbo.dbtype == "POSTGRESQL": return True
        if rdb.find("SQLite") != -1 and dbo.dbtype == "SQLITE": return True
        return False
    def builtin(h):
        return h.startswith("0")
    def installed(title):
        for lrec in loaded:
            if lrec["TITLE"] == title: return True
        return False
    s = urllib2.urlopen(URL_REPORTS).read()
    reps = s.split("&&&")
    reports = []
    i = 0
    for rp in reps:
        i += 1
        b = rp.split("###")
        d = { "TITLE" : b[0].strip(), "CATEGORY" : b[1].strip(), "DATABASE" : b[2].strip(), \
            "DESCRIPTION" : b[3].strip(), "LOCALE" : b[4].strip(), "SQL" : b[5].strip(), \
            "HTML" : b[6].strip(), "ID" : i, "TYPE": i18n._("Report", l) }
        if d["HTML"].startswith("GRAPH"): d["TYPE"] = i18n._("Chart", l)
        if d["HTML"].startswith("MAIL"): d["TYPE"] = i18n._("Mail Merge", l)
        if d["HTML"].startswith("MAP"): d["TYPE"] = i18n._("Map", l)
        if len(b) == 8: 
            d["SUBREPORTS"] = b[7].strip()
        else:
            d["SUBREPORTS"] = ""
        if not builtin(d["HTML"]) and not installed(d["TITLE"]) and database_ok(d["DATABASE"]) and version_ok(d["DATABASE"]):
            reports.append(d)
    return reports

def install_smcom_reports(dbo, user, ids):
    """
    Installs the sheltermanager.com reports with the ids given
    ids: List of report id numbers
    """
    reports = get_smcom_reports(dbo)
    for r in reports:
        if r["ID"] in ids:
            # Remove any existing report of that name first
            db.execute(dbo, "DELETE FROM customreport WHERE Title LIKE '%s'" % r["TITLE"])
            data = {"title" : r["TITLE"], 
                "category" : r["CATEGORY"], 
                "sql" : r["SQL"],
                "html": r["HTML"], 
                "description" : r["DESCRIPTION"],
                "omitheaderfooter" : r["DATABASE"].find("omitheader") != -1 and "on" or "",
                "omitcriteria" : r["DATABASE"].find("omitcriteria") != -1 and "on" or ""}
            insert_report_from_form(dbo, user, utils.PostedData(data, dbo.locale))
            # If the report has some subreports, install those too
            if r["SUBREPORTS"] != "":
                b = r["SUBREPORTS"].split("+++")
                while len(b) >= 3:
                    db.execute(dbo, "DELETE FROM customreport WHERE Title Like '%s'" % b[0].strip().replace("'", "`"))
                    data["title"] = b[0]
                    data["sql"] = b[1]
                    data["html"] = b[2]
                    insert_report_from_form(dbo, user, utils.PostedData(data, dbo.locale))
                    # Reduce the list by the 3 elements we just saw
                    if len(b) > 3:
                        b = b[3:]
                    else:
                        break

def get_reports_menu(dbo, roleids = "", superuser = False):
    """
    Reads the list of reports and returns them as a list for inserting into
    our menu structure. 
    The return value is a list of reports with a tuple containing URL and
    name. Categories are also output.
    roleids: comma separated list of roleids for the current user
    superuser: true if the user is a superuser
    """
    rv = []
    rep = get_available_reports(dbo)
    lastcat = ""
    for r in rep:
        if r["CATEGORY"] != lastcat:
            lastcat = r["CATEGORY"]
            rv.append( ["", "", "", "--cat", "", lastcat] )
        if superuser or r["VIEWROLEIDS"] == "" or utils.list_overlap(r["VIEWROLEIDS"].split("|"), roleids.split("|")):
            rv.append( [ users.VIEW_REPORT, "", "", "report?id=%d" % r["ID"], "", r["TITLE"] ] )
    return rv

def get_mailmerges_menu(dbo, roleids = "", superuser = False):
    """
    Reads the list of mail merges and returns them s a list for inserting into
    our menu structure.
    The return value is a list of merge reports with a tuple containing URL and
    name. Categories are also output.
    roleids: comma separated list of roleids for the current user
    superuser: true if the user is a superuser
    """
    mv = []
    mm = get_available_mailmerges(dbo)
    lastcat = ""
    for m in mm:
        if m["CATEGORY"] != lastcat:
            lastcat = m["CATEGORY"]
            mv.append( ["", "", "", "--cat", "", lastcat] )
        if superuser or m["VIEWROLEIDS"] == "" or utils.list_overlap(m["VIEWROLEIDS"].split("|"), roleids.split("|")):
            mv.append( [ users.MAIL_MERGE, "", "", "mailmerge?id=%d" % m["ID"], "", m["TITLE"] ] )
    return mv

def email_daily_reports(dbo, hour = -1):
    """
    Finds all reports that have addresses set in DailyEmail 
    and no criteria. It will execute each of those reports in 
    turn and email them to the addresses set.
    hour: The server hour we are at right now (GMT for sheltermanager.com
          servers). If the hour is not -1 it will be adjusted
          according to configuration.timezone before comparison.
    """
    if hour != -1: 
        hour = i18n.adjust_hour(hour, configuration.timezone(dbo))
    rs = get_available_reports(dbo, False)
    for r in rs:
        emails = utils.nulltostr(r["DAILYEMAIL"])
        runhour = r["DAILYEMAILHOUR"]
        if emails != "" and runhour == hour:
            body = execute(dbo, r["ID"], "dailyemail")
            utils.send_email(dbo, configuration.email(dbo), emails, "", r["TITLE"], body, "html")

def execute_title(dbo, title, username = "system", params = None):
    """
    Executes a custom report by a match on its title. 'params' is a tuple
    of parameters. username is the name of the user running the report.
    See the Report._SubstituteSQLParameters function for more info.
    Return value is a string containing the report as an HTML document.
    """
    crid = get_id(dbo, title)
    if crid == 0:
        return "<html><body><h1>404 Not Found</h1><p>The report '%s' does not exist.</p></body></html>" % title
    else:
        return execute(dbo, crid, username, params)

def execute(dbo, customreportid, username = "system", params = None):
    """
    Executes a custom report by its ID. 'params' is a tuple of 
    parameters. username is the name of the user running the 
    report. See the Report._SubstituteSQLParameters function for
    more info. Return value is a string containing the report as an
    HTML document.
    """
    r = Report(dbo)
    return r.Execute(customreportid, username, params)

def execute_query(dbo, customreportid, username = "system", params = None):
    """
    Executes a custom report query by its ID. 'params' is a tuple of 
    parameters. username is the name of the user running the 
    report. See the Report._SubstituteSQLParameters function for
    more info. Return value is the list of rows from the query and
    a list of columns.
    """
    r = Report(dbo)
    return r.ExecuteQuery(customreportid, username, params)

def execute_sql(dbo, title, sql, html, headerfooter = True, username = "system"):
    """
    Executes a sql/html combo as if it were a custom report.
    title: The report title
    sql: The report sql
    html: The report html
    headerfooter: Whether or not to include report HTML header/footer
    return value is the report HTML as a string
    """
    r = Report(dbo)
    r.title = title
    r.sql = sql
    r.html = html
    r.user = username
    r.omitCriteria = True
    r.omitHeaderFooter = headerfooter
    return r.Execute(0, username)

class GroupDescriptor:
    """
    Contains info on report groups
    """
    fieldName = ""
    lastFieldValue = ""
    header = ""
    footer = ""
    forceFinish = False
    lastGroupStartPosition = 0
    lastGroupEndPosition = 0

class Report:
    dbo = None
    user = ""
    reportId = 0
    criteria = ""
    queries = []
    params = []
    title = ""
    sql = ""
    html = ""
    omitCriteria = False
    omitHeaderFooter = False
    isSubReport = False
    output = ""
    CURRENCY_FIELDS = "AMT AMOUNT DONATION DAILYBOARDINGCOST COSTAMOUNT COST FEE LICENCEFEE DEPOSITAMOUNT FINEAMOUNT"
    
    def __init__(self, dbo):
        self.dbo = dbo

    def _ReadReport(self, reportId):
        """
        Reads the report info from the database and populates
        our local class variables
        """
        rs = db.query(self.dbo, "SELECT Title, HTMLBody, SQLCommand, OmitCriteria, " \
            "OmitHeaderFooter FROM customreport WHERE ID = %s" % str(reportId))
        
        # Can't do anything if the ID was invalid
        if len(rs) == 0: return

        r = rs[0]
        self.title = r["TITLE"]
        self.html = r["HTMLBODY"]
        self.sql = r["SQLCOMMAND"]
        self.omitCriteria = r["OMITCRITERIA"] > 0
        self.omitHeaderFooter = r["OMITHEADERFOOTER"] > 0
        self.isSubReport = self.sql.find("PARENTKEY") != -1

    def _ReadHeader(self):
        """
        Reads the report header from the DBFS. If the omitHeaderFooter
        flag is set, returns a basic header, if it's a subreport,
        returns nothing.
        """
        if self.omitHeaderFooter:
            return "<html><head><title></title></head><body>"
        elif self.isSubReport:
            return ""
        else:
            # Look it up from the DB
            s = dbfs.get_string(self.dbo, "head.html", "/reports")
            if s.strip() == "": s = dbfs.get_string(self.dbo, "head.dat", "/reports")
            if s.strip() == "": s = DEFAULT_REPORT_HEADER
            s = self._SubstituteTemplateHeaderFooter(s)
            return s

    def _ReadFooter(self):
        """
        Reads the report footer from the DBFS. If the omitHeaderFooter
        flag is set, returns a basic footer, if it's a subreport,
        returns nothing.
        """
        if self.omitHeaderFooter:
            return "</body></html>"
        elif self.isSubReport:
            return ""
        else:
            # Look it up from the DB
            s = dbfs.get_string(self.dbo, "foot.html", "/reports")
            if s == "": s = dbfs.get_string(self.dbo, "foot.dat", "/reports")
            if s.strip() == "": s = DEFAULT_REPORT_FOOTER
            s = self._SubstituteTemplateHeaderFooter(s)
            return s

    def _Append(self, s):
        self.output += str(s)
        return self.output

    def _p(self, s):
        self._Append("<p>%s</p>" % s)

    def _hr(self):
        self._Append("<hr />")

    def _ReplaceFields(self, s, k, v):
        """
        Replaces field tokens in HTML for real fields. 
        Escapes curly braces and dollars for HTML entities as they can blow 
        up the parser after substitution.
        s is the html string, k is the fieldname, v is the value
        """
        # Characters that denote a field token has ended
        validend = (" ", "\n", "\r", ",", "<", ">", "&" , "[", "]", "{", "}", ".", "$", "*", ":", ";", "!", "%", "^", "(", ")", "@", "~", "/", "\\", "'", "\"", "|")
        lc = s.lower()
        tok = lc.find("$")
        while tok != -1:
            aftertok = lc[tok+1+len(k):tok+1+len(k)+1]
            if lc[tok+1:tok+1+len(k)] == k.lower() and aftertok in validend:
                foundtok = s[tok+1:tok+1+len(k)]
                v = v.replace("{", "&#123;").replace("}", "&#125;")
                v = v.replace("$", "&#36;")
                s = s.replace("$" + foundtok + aftertok, v + aftertok)
                lc = s.lower()
            tok = lc.find("$", tok+1) 
        return s
        
    def _DisplayValue(self, k, v):
        """
        Returns the display version of any value
        k: fieldname
        v: value
        """
        l = self.dbo.locale
        if v is None: return ""

        if type(v) == datetime.datetime or str(v).find("00:00:00.00") != -1:
            # If the time is midnight, omit it
            if str(v).find("00:00") != -1:
                return i18n.python2display(l, v)
            else:
                return "%s %s" % (i18n.python2display(l, v), i18n.format_time(v))

        if self._IsCurrency(k):
            return i18n.format_currency(l, v)

        return str(v)

    def _IsCurrency(self, f):
        """
        Returns true if fieldname f is a currency field
        """
        return f.upper().startswith("MONEY") or self.CURRENCY_FIELDS.find(f.upper()) != -1

    def _OutputGroupBlock(self, gd, headfoot, rs):
        """
        Outputs a group block, 'gd' is the group descriptor,
        'headfoot' is 0 for header, 1 for footer, 'rs' is
        the resultset and 'rowindex' is the row of results being
        looked at
        """
        out = gd.footer
        if headfoot == 0:
            out = gd.header

        # If there aren't any records in the set, then we might as
        # well stop now
        if len(rs) == 0:
            self._Append(out)
            return

        # Replace any fields in the block based on the last row
        # in the group
        for k, v in rs[gd.lastGroupEndPosition].iteritems():
            out = self._ReplaceFields(out, k, self._DisplayValue(k, v))

        # Replace any of our special header/footer tokens
        out = self._SubstituteTemplateHeaderFooter(out)

        # Find calculation keys in our block
        startkey = out.find("{")
        while startkey != -1:

            endkey = out.find("}", startkey)
            key = out[startkey + 1:endkey]
            value = ""
            valid = False

            # {SUM.field[.round]}
            if key.lower().startswith("sum"):
                valid = True
                fields = key.lower().split(".")
                calcfield = fields[1].upper()
                
                # rounding
                roundto = 2
                if len(fields) > 2:
                    roundto = int(fields[2])

                # Loop from start of group to end of group
                total = 0.0
                for i in range(gd.lastGroupStartPosition, gd.lastGroupEndPosition + 1):
                    try:
                        fv = float(rs[i][calcfield])
                        if self._IsCurrency(fields[1]):
                            fv /= 100
                        total += fv
                    except Exception, e:
                        # Ignore anything that wasn't a number
                        pass
                fstr = "%0." + str(roundto) + "f"
                value = fstr % total

            # {COUNT.field}
            if key.lower().startswith("count"):
                valid = True
                value = str(gd.lastGroupEndPosition - gd.lastGroupStartPosition + 1)

            # {AVG.field[.round]}
            if key.lower().startswith("avg"):
                valid = True
                fields = key.lower().split(".")
                calcfield = fields[1].upper()
               
                # rounding
                roundto = 2
                if len(fields) > 2:
                    roundto = int(fields[2])

                # Loop from start of group to end of group
                total = 0.0
                num = 0
                for i in range(gd.lastGroupStartPosition, gd.lastGroupEndPosition + 1):
                    try:
                        fv = float(rs[i][calcfield])
                        if self._IsCurrency(fields[1]):
                            fv /= 100
                        total += fv
                        num += 1
                    except Exception, e:
                        # Ignore anything that wasn't a number
                        pass
                fstr = "%0." + str(roundto) + "f"
                value = fstr % (0)
                if num > 0:
                    value = fstr % (total / num)

            # {PCT.field.match[.round]}
            if key.lower().startswith("pct"):
                valid = True
                fields = key.lower().split(".")
                calcfield = fields[1].upper()
                calcfield2 = fields[2].upper()
                
                # rounding
                roundto = 2
                if len(fields) > 3:
                    roundto = int(fields[3])

                # Loop from start of group to end of group
                matched = 0
                for i in range(gd.lastGroupStartPosition, gd.lastGroupEndPosition + 1):
                    try:
                        if str(rs[i][calcfield]).strip().lower() == str(calcfield2).strip().lower():
                            matched += 1
                    except Exception, e:
                        # Ignore errors
                        pass

                outof = gd.lastGroupEndPosition - gd.lastGroupStartPosition + 1
                fstr = "%0." + str(roundto) + "f"
                value = fstr % ((matched / outof) * 100)

            # {MIN.field}
            if key.lower().startswith("min"):
                valid = True
                fields = key.lower().split(".")
                calcfield = fields[1].upper()
                
                # Loop from start of group to end of group
                minval = 0
                for i in range(gd.lastGroupStartPosition, gd.lastGroupEndPosition + 1):
                    try:
                        minval = min(minval, rs[i][calcfield])
                    except Exception, e:
                        # Ignore errors
                        pass
                if self._IsCurrency(fields[1]):
                    value = str(minval / 100.0)
                else:
                    value = str(minval)

            # {MAX.field}
            if key.lower().startswith("max"):
                valid = True
                fields = key.lower().split(".")
                calcfield = fields[1].upper()
               
                # Loop from start of group to end of group
                maxval = 0
                for i in range(gd.lastGroupStartPosition, gd.lastGroupEndPosition + 1):
                    try:
                        maxval = max(minval, rs[i][calcfield])
                    except Exception, e:
                        # Ignore errors
                        pass
                if self._IsCurrency(fields[1]):
                    value = str(maxval / 100.0)
                else:
                    value = str(maxval)

            # {FIRST.field}
            if key.lower().startswith("first"):
                valid = True
                fields = key.lower().split(".")
                calcfield = fields[1].upper()
                value = str(rs[gd.lastGroupStartPosition][calcfield])
                if self._IsCurrency(calcfield):
                    value = str(float(value) / 100)

            # {LAST.field}
            if key.lower().startswith("last"):
                valid = True
                fields = key.lower().split(".")
                calcfield = fields[1].upper()
                value = str(rs[gd.lastGroupStartPosition][calcfield])
                if self._IsCurrency(calcfield):
                    value = str(float(value) / 100)

            # {SQL.sql} - arbitrary sql command, output first
            # column of first row
            if key.lower().startswith("sql"):
                valid = True
                asql = key[4:]
                if asql.lower().startswith("select"):
                    # Select - return first row/column
                    try:
                        x = db.query_tuple(self.dbo, asql)
                        value = str(x[0][0])
                    except Exception, e:
                        value = e
                else:
                    # Action query, run it
                    try:
                        value = ""
                        db.execute(self.dbo, asql)
                    except Exception, e:
                        value = e

            # {IMAGE.animalid[.seq]} - substitutes a link to the image
            # page to direct the browser to retrieve an image. seq is
            # optional and includes image number X for the animal. If
            # seq is not given, the preferred image is used.
            if key.lower().startswith("image"):
                valid = True
                fields = key.lower().split(".")
                animalid = fields[1]
                seq = ""
                if len(fields) > 2: seq = "&seq=" + fields[2]
                value = "image?mode=animal&id=%s%s" % (animalid, seq)

            # {QR.animalid[.size]} - substitutes a link to the
            # google charting api to generate a QR code that
            # links back to an animal's record.
            if key.lower().startswith("qr"):
                valid = True
                fields = key.lower().split(".")
                animalid = fields[1]
                size = "150x150"
                if len(fields) > 2: size = fields[2]
                url = BASE_URL + "/animal?id=%s" % animalid
                value = "http://chart.apis.google.com/chart?cht=qr&chl=%s&chs=%s" % (url, size)

            # {SUBREPORT.[title].[parentField]} - embed a subreport
            if key.lower().startswith("subreport"):
                valid = True
                fields = key.lower().split(".")
                row = gd.lastGroupStartPosition

                # Get custom report ID from title
                crid = db.query_int(self.dbo, "SELECT ID FROM customreport WHERE LOWER(Title) LIKE '" + fields[1] + "'");
                if crid == 0:
                    self._p("Custom report '" + fields[1] + "' doesn't exist.")
                    valid = False

                # Get the key
                fieldname = fields[2].upper()
                fieldvalue = ""
                if not rs[row].has_key(fieldname):
                    self._p("Subreport field '" + fields[2] + "' doesn't exist.")
                    valid = False
                else:
                    fieldvalue = str(rs[row][fieldname])
                    

                # Get the content from it
                r = Report(self.dbo)
                value = r.Execute(crid, self.user, [("PARENTKEY", "No question parentkey", fieldvalue, fieldvalue  ) ] )

            # Modify our block with the token value
            if valid:
                out = out[0:startkey] + value + out[endkey+1:];

            # Find the next key
            startkey = out.find("{", startkey+1)

        # Output the HTML to the report
        self._Append(out)

    def _SubstituteTemplateHeaderFooter(self, s):
        """
        Substitutes special tokens in the report template
        header and footer. 's' is the header/footer to
        find tokens in, return value is the substituted 
        header/footer.
        """
        l = self.dbo.locale
        s = s.replace("$$TITLE$$", self.title)
        s = s.replace("$$DATE$$", i18n.python2display(l, i18n.now(self.dbo.timezone)))
        s = s.replace("$$TIME$$", i18n.format_time_now(self.dbo.timezone))
        s = s.replace("$$DATETIME$$", i18n.python2display(l, i18n.now(self.dbo.timezone)) + " " + i18n.format_time_now(self.dbo.timezone))
        s = s.replace("$$VERSION$$", i18n.get_version())
        s = s.replace("$$USER$$", self.user)
        s = s.replace("$$REGISTEREDTO$$", configuration.organisation(self.dbo))
        return s

    def _SubstituteHeaderFooter(self, headfoot, text, rs):
        """
        Outputs the header and footer blocks, 
        'headfoot' - 0 = main header, 1 = footer
        text is the text of the block,
        'rs' is the resultset and
        'rowindex' is the current row from the recordset being looked at
        """
        gd = GroupDescriptor();
        gd.lastGroupEndPosition = len(rs) - 1
        gd.lastGroupStartPosition = 0;
        gd.footer = text;
        gd.header = text;
        self._OutputGroupBlock(gd, headfoot, rs);

    def _SubstituteSQLParameters(self, params):
        """
        Substitutes tokens in the report SQL.
        'params' is expected to be a list of parameters, each
        parameter is a tuple, containing:
        (variable name, question text, substitution value, display value)
        If the parameter wasn't from a var tag, the variable name will contain 
        ASK<x> where <x> is the nth ASK tag in the SQL. In addition, the
        PARENTKEY type is used for passing a value to a subreport.
        The return value is the substituted SQL.
        """
        s = self.sql
        s = s.replace("$CURRENT_DATE$", db.python2db(i18n.now(self.dbo.timezone)))
        s = s.replace("$USER$", self.user)
        self.sql = s
        # If we don't have any parameters, no point trying to deal with these
        if params is None: return
        sp = s.find("$")
        asktagsseen = 0
        while sp != -1:
            ep = s.find("$", sp+1)
            if ep == -1: return # Stop if we have an unclosed tag
            token = s[sp+1:ep]
            value = ""
            # ASK tag
            if token.startswith("ASK"):
                asktagsseen += 1
                # Loop through the list of parameters, skipping
                # ASK tags until we get to the correct value
                pop = asktagsseen
                for p in params:
                    if p[0].startswith("ASK"):
                        pop -= 1
                        if pop == 0: 
                            value = p[2]
                            break
            # VAR tag
            if token.startswith("VAR"):
                # Just remove it from the SQL altogether
                value = ""
            # Variable replacement
            if token.startswith("@"):
                vname = token[1:]
                for p in params:
                    if p[0] == vname:
                        value = p[2]
                        break
            # PARENTKEY
            if token.startswith("PARENTKEY"):
                for p in params:
                    if p[0] == "PARENTKEY":
                        value = p[2]
                        break
            # Do the replace
            s = s[0:sp] + value + s[ep+1:]
            # Next token
            sp = s.find("$", sp)
        self.sql = s

    def GetParams(self, reportId):
        """
        Returns a list of parameters required for a report, 
        with their types
        'reportId' is the ID of the report to get parameters for.
        Returns a list of parameters, each item is a list containing a
        variable name (or ASK with a number for a one-shot ask), a type 
        (DATE, ANIMAL, LITTER, SPECIES, LOCATION, TYPE, NUMBER, STRING)
        and a question string.
        """
        self._ReadReport(reportId)
        params = []

        s = self.sql
        sp = s.find("$")
        asks = 0
        while sp != -1:
            
            # Has to be ASK or VAR - if it isn't, keep looking
            if s[sp:sp+4] != "$ASK" and s[sp:sp+4] != "$VAR":
                sp = s.find("$", sp+1)
                continue

            ep = s.find("$", sp+1)
            token = s[sp+1:ep]
            paramtype = ""
            varname = ""
            question = ""

            # ASK
            if token.startswith("ASK"):                
                asks += 1
                varname = "ASK" + str(asks)

                # Get the type
                nsp = token.find(" ", 5)
                if nsp == -1: nsp = len(token)
                paramtype = token[4:nsp]

                # Does the type need a string?
                if paramtype == "DATE" or paramtype == "NUMBER" or paramtype == "STRING":
                    question = token[nsp+1:]

            # VAR
            if token.startswith("VAR"):
                fields = token.split(" ")
                
                # Get the name
                varname = fields[1]

                # The type
                paramtype = fields[2]

                # And the string if it needs one
                if paramtype == "DATE" or paramtype == "NUMBER" or paramtype == "STRING":
                    sp1 = token.find(" ", 5)
                    sp2 = token.find(" ", sp1 + 1)
                    question = token[sp2+1:]

            # Bundle them up
            params.append((varname, paramtype, question))

            # Next token
            sp = s.find("$", ep+1)

        return params

    def OutputCriteria(self):
        """
        Outputs a human readable string of any criteria set into the 
        report document.
        """
        l = self.dbo.locale
        # Calculate criteria from parameters
        self.criteria = ""
        if self.params is not None:
            for p in self.params:
                self.criteria += p[1] + ": " + p[3] + "<br />"

        # Display criteria if there is some and the option is on
        if self.criteria != "" and not self.omitCriteria and not self.isSubReport:
            self._p(i18n._("Criteria:", l))
            self._p(self.criteria)
            self._hr()

    def Execute(self, reportId = 0, username = "system", params = None):
        """
        Executes a report
        'reportId' is the ID of the report to run, 'username' is the
        name of the user running the reoprt, 'params' is a list
        of values in order to substitute tokens in the report SQL for.
        They should all be strings and will be literally replaced.
        Return value is the HTML output of the report.
        """
        self.user = username
        if reportId != 0: self._ReadReport(reportId)
        self.params = params
        self.output = ""

        # Substitute our parameters in the SQL
        self._SubstituteSQLParameters(params)

        if self.html.upper().startswith("GRAPH"):
            return self._GenerateGraph()
        elif self.html.upper().startswith("MAP"):
            return self._GenerateMap()
        else:
            self._GenerateReport()

        return self.output

    def ExecuteQuery(self, reportId = 0, username = "system", params = None):
        """
        Executes the query portion of a report only and then returns
        the query results and column order.
        """
        self.user = username
        if reportId != 0: self._ReadReport(reportId)
        self.params = params
        self.output = ""

        # Substitute our parameters in the SQL
        self._SubstituteSQLParameters(params)

        # Make sure our query is a SELECT or (SELECT
        if not self.sql.strip().lower().startswith("select") and \
           not self.sql.strip().lower().startswith("(select"):
            raise utils.ASMValidationError("Reports must be based on a SELECT query.")

        # Run the query
        rs = None
        cols = None
        try:
            rs = db.query(self.dbo, self.sql)
            cols = db.query_columns(self.dbo, self.sql)
        except Exception,e:
            self._p(e)
        return (rs, cols)

    def _GenerateGraph(self):
        """
        Does the work of generating a graph. Graph queries have to return rows that
        have two or three columns and obey either of the following patterns:
        ( X_AXIS_LABEL, VALUE ) - assumed for two columns
        ( SERIES_LABEL, X_AXIS_VALUE, Y_AXIS_VALUE ) - assumed for three columns, all items with the
                                                same series label will be plotted on a separate line
                                                and both VALUE columns must be numbers
        The html can be just the word GRAPH for a bar chart
        alternatively, a type can be specified as well:
        GRAPH [ LINES | BARS | POINTS | STEPS ]
        """
        l = self.dbo.locale
        self._Append(html.graph_header(self.title))

        # Run the graph query, bail out if we have an error
        try:
            rs, cols = db.query_tuple_columns(self.dbo, self.sql)
        except Exception,e:
            self._p(e)
            self._Append("</body></html>")
            return self.output

        # Output any criteria given at the top of the chart
        self.OutputCriteria()

        # Check for no data
        if len(rs) == 0:
            self._p(i18n._("No data.", l))
            self._Append("</body></html>")
            return self.output

        self._Append("""<script type="text/javascript">
            $(function() {
                $("#placeholder").show();
                $.plot($("#placeholder"), [
        """)

        # Check for plot type
        mode = "bars: { show: true }"
        if self.html.find("LINES") != -1:
            mode = "lines: { show: true }"
        elif self.html.find("BARS") != -1:
            mode = "bars: { show: true }"
        elif self.html.find("POINTS") != -1:
            mode = "points: { show: true }"
        elif self.html.find("STEPS") != -1:
            mode = "lines: { show: true, steps: true }"
        elif self.html.find("PIE") != -1:
            mode = "pie: { show: true }"

        ticks = []
        i = 0

        # Two column (axis/value) mode for pie charts
        if len(rs[0]) == 2 and mode.startswith("pie"):
            values = []
            for r in rs:
                values.append("{ label: '%s (%s)', data: %s }" % ( str(r[0]), str(r[1]), str(r[1]) ))
            self._Append(",".join(values))
            self._Append("]")
            # Handle using pie chart plugin if selected 
            if mode.startswith("pie"):
                self._Append("""
                , { series: { pie: { show: true } }
                """)

        # Two column (axis/value) mode for plot charts
        elif len(rs[0]) == 2:
            values = []
            for r in rs:
                values.append("[%d, %s]" % (i, str(r[1])))
                ticks.append("[%d, '%s']" % (i, str(r[0])))
                i += 1
            self._Append("{ label: '%s', \n" % cols[1])
            self._Append("data: [%s], \n%s\n }" % (",".join(values), mode))
            self._Append("""\n], {
                xaxis: {
                    ticks: [%s]
                }
            """ % ",".join(ticks))
            # Handle using pie chart plugin if selected 
            if mode.startswith("pie"):
                self._Append("""
                , series: { pie: { show: true } }
                """)

        # Three column (label/axis/value) mode for either type
        else:
            values = {}
            for r in rs:
                if not values.has_key(r[0]):
                    values[r[0]] = []
                values[r[0]].append("[%s, %s]" % (str(r[1]), str(r[2])))
            for k, v in values.iteritems():
                self._Append("{ label: '%s', \n" % k)
                self._Append("data: [%s], \n%s\n },\n" % (",".join(v), mode))
            # Remove trailing comma
            self.output = self.output[0:len(self.output)-1]
            self._Append("""\n], {
                xaxis: {
                    tickDecimals: 0 
                }
            """)
            # Handle using pie chart plugin if selected 
            if mode.startswith("pie"):
                self._Append("""
                , series: { pie: { show: true } }
                """)
        
        self._Append("""
            });
        """)
        self._Append("""
            });
            </script>
            </body>
            </html>""")
        return self.output

    def _GenerateMap(self):
        """
        Does the work of generating a map. Map queries have to return rows that
        have two columns:
        ( LATLONG, POPUP )
        The html should be just the word MAP
        """
        l = self.dbo.locale
        self._Append(html.map_header(self.title))

        # Run the map query, bail out if we have an error
        try:
            rs, cols = db.query_tuple_columns(self.dbo, self.sql)
        except Exception,e:
            self._p(e)
            self._Append("</body></html>")
            return self.output

        # Output any criteria given at the top of the chart
        self.OutputCriteria()

        # Check for no data
        if len(rs) == 0:
            self._p(i18n._("No data.", l))
            self._Append("</body></html>")
            return self.output

        # Check we have two columns
        if len(rs[0]) != 2:
            self._p("Map query should have two columns.")
            self._Append("</body></html>")
            return self.output

        self._Append('<div id="embeddedmap" style="width: 100%%; height: 600px; color: #000" />\n')
        self._Append("<script type='text/javascript'>\n" \
            "setTimeout(function() {\n" \
            "var points = \n")

        p = []
        lastlatlong = ""
        for g in rs:
            p.append({ "latlong": g[0], "popuptext": g[1] })
            lastlatlong = g[0]

        self._Append( html.json(p) + ";\n" );
        self._Append( "mapping.draw_map(\"embeddedmap\", 10, \"%s\", points);\n" % lastlatlong );
        self._Append( "}, 50);\n" );
        self._Append("""
            </script>
            </body>
            </html>""")
        return self.output

    def _GenerateReport(self):
        """
        Does the work of generating the report content
        """

        # String indexes within report html string to where 
        # tokens begin and end
        headerstart = 0
        headerend = 0
        bodystart = 0
        bodyend = 0
        footerstart = 0
        footerend = 0
        groupstart = 0
        groupend = 0

        tempbody = ""
        cheader = ""
        cbody = ""
        cfooter = ""

        l = self.dbo.locale

        htmlheader = self._ReadHeader()
        htmlheaderstart = self.html.find("$$HTMLHEADER")
        htmlheaderend = self.html.find("HTMLHEADER$$")
        if htmlheaderstart != -1 and htmlheaderend != -1:
            htmlheader = self.html[htmlheaderstart+12:htmlheaderend]

        htmlfooter = self._ReadFooter()
        htmlfooterstart = self.html.find("$$HTMLFOOTER")
        htmlfooterend = self.html.find("HTMLFOOTER$$")
        if htmlfooterstart != -1 and htmlfooterend != -1:
            htmlfooter = self.html[htmlfooterstart+12:htmlfooterend]

        # Start the report off with the HTML header
        self._Append(htmlheader)

        headerstart = self.html.find("$$HEADER")
        headerend = self.html.find("HEADER$$")
        if headerstart == -1 or headerend == -1:
            self._p("The header block of your report is invalid.")
            return
        cheader = self.html[headerstart+8:headerend];

        bodystart = self.html.find("$$BODY");
        bodyend = self.html.find("BODY$$");

        if bodystart == -1 or bodyend == -1:
            self._p("The body block of your report is invalid.")
            return
        cbody = self.html[bodystart+6:bodyend];

        footerstart = self.html.find("$$FOOTER");
        footerend = self.html.find("FOOTER$$");

        if footerstart == -1 or footerend == -1:
            self._p("The footer block of your report is invalid.")
            return
        cfooter = self.html[footerstart+8:footerend];

        # Optional NODATA block
        nodata = ""
        nodatastart = self.html.find("$$NODATA")
        nodataend = self.html.find("NODATA$$")
        if nodatastart != -1 and nodataend != -1:
            nodata = self.html[nodatastart+8:nodataend]

        # Parse all groups from the HTML
        groups = []
        groupstart = self.html.find("$$GROUP_")

        while groupstart != -1:
            groupend = self.html.find("GROUP$$", groupstart);

            if groupend == -1:
                self._p("A group block of your report is invalid (missing GROUP$$ closing tag)")
                return

            ghtml = self.html[groupstart:groupend];
            ghstart = ghtml.find("$$HEAD");
            if ghstart == -1:
                self._p("A group block of your report is invalid (no group $$HEAD)")
                return

            ghstart += 6;
            ghend = ghtml.find("$$FOOT", ghstart);

            if ghend == -1:
                self._p("A group block of your report is invalid (no group $$FOOT)")
                return

            gd = GroupDescriptor();
            gd.header = ghtml[ghstart:ghend];
            gd.footer = ghtml[ghend+6:];
            gd.fieldName = ghtml[8:ghstart-6].strip().upper();
            groups.append(gd);
            groupstart = self.html.find("$$GROUP_", groupend);

        # Scan the ORDER BY clause to make sure the order
        # matches the grouping levels.  
        if len(groups) > 0:

            lsql = self.sql.lower();
            startorder = lsql.find("order by")

            if startorder == -1:
                self._p("You have grouping levels on this report without an ORDER BY clause.")
                return

            orderBy = lsql[startorder:]
            ok = False

            for gd in groups:
                ok = -1 != orderBy.find(gd.fieldName.lower())
                if not ok: break

            # This breaks expressions as ORDER BY - let's give the user the power to
            # shoot themselves in the foot here.
            #if not ok:
            #    self._p("Your ORDER BY clause does not match the order of your groups.")
            #    return

        # Output any criteria given at the top of the report
        self.OutputCriteria()

        # Make sure our query is a SELECT or (SELECT
        if not self.sql.strip().lower().startswith("select") and \
           not self.sql.strip().lower().startswith("(select"):
            raise utils.ASMValidationError("Reports must be based on a SELECT query.")

        # Run the query
        rs = None
        try:
            rs = db.query(self.dbo, self.sql)
        except Exception,e:
            self._p(e)

        first_record = True

        # If there are no records, show a message to say so
        # but only if it's not a subreport
        if rs is None or len(rs) == 0:
            if not self.isSubReport:
                if nodata == "":
                    self._p(i18n._("No data to show on the report.", l))
                else:
                    self._Append(nodata)
            return

        # Add the header to the report
        self._SubstituteHeaderFooter(HEADER, cheader, rs)

        # Construct our report
        for row in range(0, len(rs)):

            # If an outer group has changed, we need to end
            # the inner groups first
            if not first_record:
                # This same flag is used to determine whether or
                # not to update the header
                cascade = False

                # Loop through the groups in ascending order.
                # If the switch value for an outer group changes,
                # we need to force finishing of its inner groups.
                for gd in groups:
                    if cascade or not gd.lastFieldValue == rs[row][gd.fieldName]:
                        # Mark this one for update
                        gd.forceFinish = True
                        gd.lastGroupEndPosition = row - 1
                        cascade = True
                    else:
                        gd.forceFinish = False

                # Now do each group footer in reverse order
                for gd in reversed(groups):
                    if gd.forceFinish:
                        # Output the footer, switching the
                        # field values and calculating any totals
                        self._OutputGroupBlock(gd, FOOTER, rs)

            # Do each header in ascending order
            for gd in groups:
                if gd.forceFinish or first_record:
                    # Mark the position
                    gd.lastGroupStartPosition = row
                    gd.lastGroupEndPosition = row

                    # Output the header, switching field values
                    # and calculating any totals
                    self._OutputGroupBlock(gd, HEADER, rs)

            first_record = False

            # Make a temp string to hold the body block 
            # while we substitute fields for tags
            tempbody = cbody
            for k, v in rs[row].iteritems():
                tempbody = self._ReplaceFields(tempbody, k, self._DisplayValue(k, v))

            # Update the last value for each group
            for gd in groups:
                try:
                    gd.lastFieldValue = rs[row][gd.fieldName]
                except Exception,e:
                    self._p(e)

            # Deal with any non-field/calculation keys
            startkey = tempbody.find("{")
            while startkey != -1:
                endkey = tempbody.find("}", startkey)
                key = tempbody[startkey+1:endkey]
                value = ""
                valid = False

                # {SQL.sql}
                if key.lower().startswith("sql"):
                    valid = True
                    asql = key[4:]
                    if asql.lower().startswith("select"):
                        # Select - return first row/column
                        try:
                            x = db.query_tuple(self.dbo, asql)
                            value = str(x[0][0])
                        except Exception, e:
                            value = e
                    else:
                        # Action query, run it
                        try:
                            value = ""
                            db.execute(self.dbo, asql)
                        except Exception, e:
                            value = e

                # {IMAGE.animalid[.seq]} - substitutes a link to the image
                # page to direct the browser to retrieve an image. seq is
                # optional and includes image number X for the animal. If
                # seq is not given, the preferred image is used.
                if key.lower().startswith("image"):
                    valid = True
                    fields = key.lower().split(".")
                    if len(fields) < 2:
                        self._p("Invalid IMAGE tag, requires 2 components: %s" % key)
                        valid = False
                        startkey = tempbody.find("{", startkey+1)
                        continue
                    animalid = fields[1]
                    seq = ""
                    if len(fields) > 2: seq = "&seq=" + fields[2]
                    value = "image?mode=animal&id=%s%s" % (animalid, seq)

                # {QR.animalid[.size]} - substitutes a link to the
                # google charting api to generate a QR code that
                # links back to an animal's record.
                if key.lower().startswith("qr"):
                    valid = True
                    fields = key.lower().split(".")
                    if len(fields) < 2:
                        self._p("Invalid QR tag, requires 2 components: %s" % key)
                        valid = False
                        startkey = tempbody.find("{", startkey+1)
                        continue
                    animalid = fields[1]
                    size = "150x150"
                    if len(fields) > 2: size = fields[2]
                    url = BASE_URL + "/animal?id=%s" % animalid
                    value = "http://chart.apis.google.com/chart?cht=qr&chl=%s&chs=%s" % (url, size)

                # {SUBREPORT.[title].[parentField]} - embed a subreport
                if key.lower().startswith("subreport"):
                    valid = True
                    fields = key.lower().split(".")
                    if len(fields) < 3:
                        self._p("Invalid SUBREPORT tag, requires 3 components: %s" % key)
                        valid = False
                        startkey = tempbody.find("{", startkey+1)
                        continue
                    
                    # Get custom report ID from title
                    crid = db.query_int(self.dbo, "SELECT ID FROM customreport WHERE LOWER(Title) LIKE '" + fields[1] + "'");
                    if crid == 0:
                        self._p("Custom report '" + fields[1] + "' doesn't exist.")
                        valid = False

                    # Get the key
                    fieldname = fields[2].upper()
                    fieldvalue = ""
                    if not rs[row].has_key(fieldname):
                        self._p("Subreport field '" + fields[2] + "' doesn't exist.")
                        valid = False
                    else:
                        fieldvalue = str(rs[row][fieldname])
                        

                    # Get the content from it
                    r = Report(self.dbo)
                    value = r.Execute(crid, self.user, [("PARENTKEY", "No question parentkey", fieldvalue, fieldvalue  ) ] )

                if valid:
                    tempbody = tempbody[0:startkey] + value + tempbody[endkey+1:]

                # next key
                startkey = tempbody.find("{", startkey+1)

            # Add the substituted body block to our report
            self._Append(tempbody)

        # Add the final group footers if there are any
        row = len(rs) - 1
        for gd in reversed(groups):
            gd.lastGroupEndPosition = row
            self._OutputGroupBlock(gd, FOOTER, rs)

        # And the report footer
        self._SubstituteHeaderFooter(FOOTER, cfooter, rs)

        # HTML footer to finish 
        self._Append(htmlfooter)

